
// Generated by Akka gRPC. DO NOT EDIT.
package smartarbitrage.api.interface.internal

import scala.concurrent.ExecutionContext

import io.grpc.ManagedChannel
import io.grpc.MethodDescriptor

import akka.grpc.GrpcClientSettings

import akka.grpc.scaladsl.AkkaGrpcClient

import akka.grpc.internal.Marshaller
import akka.grpc.internal.NettyClientUtils
import akka.grpc.internal.ClientState

import akka.stream.Materializer

import akka.grpc.scaladsl.StreamResponseRequestBuilder
import akka.grpc.internal.ScalaServerStreamingRequestBuilder
import akka.grpc.scaladsl.SingleResponseRequestBuilder
import akka.grpc.internal.ScalaUnaryRequestBuilder

// Not sealed so users can extend to write their stubs
trait GatewayApiServiceClient extends GatewayApiService with GatewayApiServiceClientPowerApi with AkkaGrpcClient

object GatewayApiServiceClient {
  def apply(settings: GrpcClientSettings)(implicit mat: Materializer, ex: ExecutionContext): GatewayApiServiceClient =
    new DefaultGatewayApiServiceClient(settings)
}

final class DefaultGatewayApiServiceClient(settings: GrpcClientSettings)(implicit mat: Materializer, ex: ExecutionContext) extends GatewayApiServiceClient {
  import DefaultGatewayApiServiceClient._

  private val options = NettyClientUtils.callOptions(settings)
  private val clientState = new ClientState(settings)

  
    private def getPositionsRequestBuilder(channel:scala.concurrent.Future[ManagedChannel]) = {
      
        val fqName = "smartarbitrage.api.interface.internal.GatewayApiService.GetPositions"
        
          new ScalaServerStreamingRequestBuilder(getPositionsDescriptor, fqName, channel, options, settings)
        
      
    }
  
    private def placeLimitOrderRequestBuilder(channel:scala.concurrent.Future[ManagedChannel]) = {
      
        new ScalaUnaryRequestBuilder(placeLimitOrderDescriptor, channel, options, settings)
      
    }
  

  
    /**
     * Lower level "lifted" version of the method, giving access to request metadata etc.
     * prefer getPositions(smartarbitrage.api.interface.internal.PositionRequest) if possible.
     */
    
      override def getPositions(): StreamResponseRequestBuilder[smartarbitrage.api.interface.internal.PositionRequest, smartarbitrage.api.interface.internal.PositionReply] =
        clientState.withChannel(getPositionsRequestBuilder _)
    

    /**
     * For access to method metadata use the parameterless version of getPositions
     */
    def getPositions(in: smartarbitrage.api.interface.internal.PositionRequest): akka.stream.scaladsl.Source[smartarbitrage.api.interface.internal.PositionReply, akka.NotUsed] =
      getPositions().invoke(in)
  
    /**
     * Lower level "lifted" version of the method, giving access to request metadata etc.
     * prefer placeLimitOrder(smartarbitrage.api.interface.internal.PlaceLimitOrderRequest) if possible.
     */
    
      override def placeLimitOrder(): SingleResponseRequestBuilder[smartarbitrage.api.interface.internal.PlaceLimitOrderRequest, smartarbitrage.api.interface.internal.PlaceLimitOrderReply] =
        clientState.withChannel(placeLimitOrderRequestBuilder _)
    

    /**
     * For access to method metadata use the parameterless version of placeLimitOrder
     */
    def placeLimitOrder(in: smartarbitrage.api.interface.internal.PlaceLimitOrderRequest): scala.concurrent.Future[smartarbitrage.api.interface.internal.PlaceLimitOrderReply] =
      placeLimitOrder().invoke(in)
  

  override def close(): scala.concurrent.Future[akka.Done] = clientState.close()
  override def closed(): scala.concurrent.Future[akka.Done] = clientState.closed()

}



private object DefaultGatewayApiServiceClient {

  def apply(settings: GrpcClientSettings)(implicit mat: Materializer, ex: ExecutionContext): GatewayApiServiceClient =
    new DefaultGatewayApiServiceClient(settings)

  import GatewayApiService.Serializers._

  
    private val getPositionsDescriptor: MethodDescriptor[smartarbitrage.api.interface.internal.PositionRequest, smartarbitrage.api.interface.internal.PositionReply] =
      MethodDescriptor.newBuilder()
        .setType(
  
  
   MethodDescriptor.MethodType.SERVER_STREAMING 
  
)
        .setFullMethodName(MethodDescriptor.generateFullMethodName("smartarbitrage.api.interface.internal.GatewayApiService", "GetPositions"))
        .setRequestMarshaller(new Marshaller(PositionRequestSerializer))
        .setResponseMarshaller(new Marshaller(PositionReplySerializer))
        .setSampledToLocalTracing(true)
        .build()
  
    private val placeLimitOrderDescriptor: MethodDescriptor[smartarbitrage.api.interface.internal.PlaceLimitOrderRequest, smartarbitrage.api.interface.internal.PlaceLimitOrderReply] =
      MethodDescriptor.newBuilder()
        .setType(
   MethodDescriptor.MethodType.UNARY 
  
  
  
)
        .setFullMethodName(MethodDescriptor.generateFullMethodName("smartarbitrage.api.interface.internal.GatewayApiService", "PlaceLimitOrder"))
        .setRequestMarshaller(new Marshaller(PlaceLimitOrderRequestSerializer))
        .setResponseMarshaller(new Marshaller(PlaceLimitOrderReplySerializer))
        .setSampledToLocalTracing(true)
        .build()
  
}

trait GatewayApiServiceClientPowerApi {
  
    /**
     * Lower level "lifted" version of the method, giving access to request metadata etc.
     * prefer getPositions(smartarbitrage.api.interface.internal.PositionRequest) if possible.
     */
    
      def getPositions(): StreamResponseRequestBuilder[smartarbitrage.api.interface.internal.PositionRequest, smartarbitrage.api.interface.internal.PositionReply] = ???
    
  
    /**
     * Lower level "lifted" version of the method, giving access to request metadata etc.
     * prefer placeLimitOrder(smartarbitrage.api.interface.internal.PlaceLimitOrderRequest) if possible.
     */
    
      def placeLimitOrder(): SingleResponseRequestBuilder[smartarbitrage.api.interface.internal.PlaceLimitOrderRequest, smartarbitrage.api.interface.internal.PlaceLimitOrderReply] = ???
    
  

}
